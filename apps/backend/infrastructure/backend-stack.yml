AWSTemplateFormatVersion: '2010-09-09'
Description: 'ECS Cluster with Auto Scaling EC2 Instances and Application Load Balancer'

Parameters:
  ECRRepositoryName:
    Type: String
    Description: Name of the ECR repository
  ImageTag:
    Type: String
    Description: Tag of the Docker image to deploy
  ECSAMI:
    Type: AWS::SSM::Parameter::Value<AWS::EC2::Image::Id>
    Default: /aws/service/ecs/optimized-ami/amazon-linux-2/recommended/image_id
    Description: The AMI ID used for the cluster, leave it as the default value to get the latest AMI
  InstanceType:
    Type: String
    Default: t3.micro
    Description: EC2 instance type
  DesiredCapacity:
    Type: Number
    Default: 1
    Description: Desired number of EC2 instances in the Auto Scaling Group
  MaxSize:
    Type: Number
    Default: 2
    Description: Maximum number of EC2 instances in the Auto Scaling Group
  MinSize:
    Type: Number
    Default: 1
    Description: Minimum number of EC2 instances in the Auto Scaling Group
  DomainName:
    Type: String
    Description: Domain name for the ALB
  HostedZoneId:
    Type: String
    Description: The ID of the hosted zone in Route 53

Resources:
  VPC:
    Type: AWS::EC2::VPC
    Properties:
      CidrBlock: 10.0.0.0/16
      EnableDnsHostnames: true
      EnableDnsSupport: true
      Tags:
        - Key: Name
          Value: ECS Cluster VPC

  InternetGateway:
    Type: AWS::EC2::InternetGateway
    Properties:
      Tags:
        - Key: Name
          Value: ECS Cluster IGW

  InternetGatewayAttachment:
    Type: AWS::EC2::VPCGatewayAttachment
    Properties:
      InternetGatewayId: !Ref InternetGateway
      VpcId: !Ref VPC

  PublicSubnet1:
    Type: AWS::EC2::Subnet
    Properties:
      VpcId: !Ref VPC
      AvailabilityZone: !Select [0, !GetAZs '']
      CidrBlock: 10.0.1.0/24
      MapPublicIpOnLaunch: true
      Tags:
        - Key: Name
          Value: Public Subnet 1

  PublicSubnet2:
    Type: AWS::EC2::Subnet
    Properties:
      VpcId: !Ref VPC
      AvailabilityZone: !Select [1, !GetAZs '']
      CidrBlock: 10.0.2.0/24
      MapPublicIpOnLaunch: true
      Tags:
        - Key: Name
          Value: Public Subnet 2

  # Instead of public subnet 3 and 4 use the private subnets commented out below.
  # Using public subnets for the ec2 instances for this demo so I stay within the free tier
  # because if they were in private subnets I'd need a vpc endpoint interface or a NAT so the
  # instances could communicate with the ecs service
  PublicSubnet3:
    Type: AWS::EC2::Subnet
    Properties:
      VpcId: !Ref VPC
      AvailabilityZone: !Select [0, !GetAZs '']
      CidrBlock: 10.0.3.0/24
      MapPublicIpOnLaunch: true
      Tags:
        - Key: Name
          Value: Public Subnet 3

  PublicSubnet4:
    Type: AWS::EC2::Subnet
    Properties:
      VpcId: !Ref VPC
      AvailabilityZone: !Select [1, !GetAZs '']
      CidrBlock: 10.0.4.0/24
      MapPublicIpOnLaunch: true
      Tags:
        - Key: Name
          Value: Public Subnet 4

  # PrivateSubnet1:
  #   Type: AWS::EC2::Subnet
  #   Properties:
  #     VpcId: !Ref VPC
  #     AvailabilityZone: !Select [0, !GetAZs '']
  #     CidrBlock: 10.0.3.0/24
  #     MapPublicIpOnLaunch: false
  #     Tags:
  #       - Key: Name
  #         Value: Private Subnet 1

  # PrivateSubnet2:
  #   Type: AWS::EC2::Subnet
  #   Properties:
  #     VpcId: !Ref VPC
  #     AvailabilityZone: !Select [1, !GetAZs '']
  #     CidrBlock: 10.0.4.0/24
  #     MapPublicIpOnLaunch: false
  #     Tags:
  #       - Key: Name
  #         Value: Private Subnet 2

  PublicRouteTable:
    Type: AWS::EC2::RouteTable
    Properties:
      VpcId: !Ref VPC
      Tags:
        - Key: Name
          Value: Public Route Table

  DefaultPublicRoute:
    Type: AWS::EC2::Route
    DependsOn: InternetGatewayAttachment
    Properties:
      RouteTableId: !Ref PublicRouteTable
      DestinationCidrBlock: 0.0.0.0/0
      GatewayId: !Ref InternetGateway

  PublicSubnet1RouteTableAssociation:
    Type: AWS::EC2::SubnetRouteTableAssociation
    Properties:
      RouteTableId: !Ref PublicRouteTable
      SubnetId: !Ref PublicSubnet1

  PublicSubnet2RouteTableAssociation:
    Type: AWS::EC2::SubnetRouteTableAssociation
    Properties:
      RouteTableId: !Ref PublicRouteTable
      SubnetId: !Ref PublicSubnet2

  PublicSubnet3RouteTableAssociation:
    Type: AWS::EC2::SubnetRouteTableAssociation
    Properties:
      RouteTableId: !Ref PublicRouteTable
      SubnetId: !Ref PublicSubnet3

  PublicSubnet4RouteTableAssociation:
    Type: AWS::EC2::SubnetRouteTableAssociation
    Properties:
      RouteTableId: !Ref PublicRouteTable
      SubnetId: !Ref PublicSubnet4

  # PrivateRouteTable1:
  #   Type: AWS::EC2::RouteTable
  #   Properties:
  #     VpcId: !Ref VPC
  #     Tags:
  #       - Key: Name
  #         Value: Private Route Table 1

  # PrivateSubnet1RouteTableAssociation:
  #   Type: AWS::EC2::SubnetRouteTableAssociation
  #   Properties:
  #     RouteTableId: !Ref PrivateRouteTable1
  #     SubnetId: !Ref PrivateSubnet1

  # PrivateRouteTable2:
  #   Type: AWS::EC2::RouteTable
  #   Properties:
  #     VpcId: !Ref VPC
  #     Tags:
  #       - Key: Name
  #         Value: Private Route Table 2

  # PrivateSubnet2RouteTableAssociation:
  #   Type: AWS::EC2::SubnetRouteTableAssociation
  #   Properties:
  #     RouteTableId: !Ref PrivateRouteTable2
  #     SubnetId: !Ref PrivateSubnet2

  ECSCluster:
    Type: AWS::ECS::Cluster
    Properties:
      ClusterName: BackendCluster
      ClusterSettings:
        - Name: containerInsights
          Value: enabled

  ECSAutoScalingGroup:
    Type: AWS::AutoScaling::AutoScalingGroup
    DependsOn:
      - ECSCluster
      - EC2Role
    UpdatePolicy:
      AutoScalingRollingUpdate:
        MinInstancesInService: 1
        MaxBatchSize: 2
        PauseTime: PT2M
        WaitOnResourceSignals: true
        MinSuccessfulInstancesPercent: 100
    Properties:
      AutoScalingGroupName: ECSInstances
      VPCZoneIdentifier:
        - !Ref PublicSubnet3 # set to private subnets in production
        - !Ref PublicSubnet4 # using public to avoid vpc endpoint costs (for ecs service)
      LaunchTemplate:
        LaunchTemplateId: !Ref ECSLaunchTemplate
        Version: !GetAtt ECSLaunchTemplate.LatestVersionNumber
      MinSize: !Ref MinSize
      MaxSize: !Ref MaxSize
      NewInstancesProtectedFromScaleIn: false
      Tags:
        - Key: Name
          Value: ECSInstances
          PropagateAtLaunch: true

  ECSLaunchTemplate:
    Type: AWS::EC2::LaunchTemplate
    Metadata:
      AWS::CloudFormation::Init:
        configSets:
          full_install: [install_deps, verify_instance_health, signal_cfn]
        # Install dependencies
        install_deps:
          commands:
            InstallDependencies:
              command: |
                yum install -y awscli jq
        # Check the ECS API to see if this instance is available as capacity
        # inside of the ECS cluster, and wait for it to run the healthiness daemon
        verify_instance_health:
          commands:
            ECSHealthCheck:
              command: |
                echo "Introspecting ECS agent status"
                find_container_instance_arn() {
                  CONTAINER_INSTANCE_ARN=$(curl --connect-timeout 1 --max-time 1 -s http://localhost:51678/v1/metadata | jq -r '.ContainerInstanceArn')
                }
                find_container_instance_arn
                while [ "$CONTAINER_INSTANCE_ARN" == "" ]; do sleep 2; find_container_instance_arn; done
                echo "Container Instance ARN: $CONTAINER_INSTANCE_ARN"

                echo "Waiting for at least one running task"
                count_instance_tasks() {
                  NUMBER_OF_TASKS=$(curl -s http://localhost:51678/v1/tasks | jq '.Tasks | length')
                }
                count_instance_tasks
                while [ $NUMBER_OF_TASKS -lt 1 ]; do sleep 2; count_instance_tasks; done

                echo "Instance $CONTAINER_INSTANCE_ARN is now hosting $NUMBER_OF_TASKS task(s)"
        # This signals back to CloudFormation once the instance has become healthy in ECS
        # and has started hosting at least one task
        signal_cfn:
          commands:
            SignalCloudFormation:
              command: !Sub |
                /opt/aws/bin/cfn-signal -e $? --stack ${AWS::StackId} --resource ECSAutoScalingGroup --region ${AWS::Region}
    Properties:
      LaunchTemplateData:
        ImageId: !Ref ECSAMI
        InstanceType: !Ref InstanceType
        SecurityGroupIds:
          - !GetAtt EC2SecurityGroup.GroupId
        IamInstanceProfile:
          Arn: !GetAtt EC2InstanceProfile.Arn
        UserData:
          Fn::Base64: !Sub |
            #!/bin/bash -xe
            echo ECS_CLUSTER=${ECSCluster} >> /etc/ecs/ecs.config
            echo ECS_AVAILABLE_LOGGING_DRIVERS='["json-file","awslogs"]' >> /etc/ecs/ecs.config
            yum install -y aws-cfn-bootstrap
            /opt/aws/bin/cfn-signal -e $? --stack ${AWS::StackName} --resource ECSAutoScalingGroup --region ${AWS::Region}
            /opt/aws/bin/cfn-signal -e $? --stack ${AWS::StackName} --resource ECSAutoScalingGroup --region ${AWS::Region}

  EC2InstanceProfile:
    Type: AWS::IAM::InstanceProfile
    Properties:
      Path: /
      Roles:
        - !Ref EC2Role

  EC2SecurityGroup:
    Type: AWS::EC2::SecurityGroup
    Properties:
      GroupDescription: Security group for ECS instances
      VpcId: !Ref VPC
      SecurityGroupIngress:
        - IpProtocol: tcp
          FromPort: 0
          ToPort: 65535
          SourceSecurityGroupId: !Ref ALBSecurityGroup

  # Role for the EC2 hosts. This allows the ECS agent on the EC2 hosts
  # to communicate with the ECS control plane, as well as download the docker
  # images from ECR to run on your host.
  EC2Role:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Statement:
          # Allow the EC2 instances to assume this role
          - Effect: Allow
            Principal:
              Service: [ec2.amazonaws.com]
            Action: ['sts:AssumeRole']
      Path: /
      ManagedPolicyArns:
        - arn:aws:iam::aws:policy/service-role/AmazonEC2ContainerServiceforEC2Role

  # Create an ECS capacity provider to attach the ASG to the ECS cluster
  # so that it auto scales as we launch more containers
  CapacityProvider:
    Type: AWS::ECS::CapacityProvider
    Properties:
      AutoScalingGroupProvider:
        AutoScalingGroupArn: !Ref ECSAutoScalingGroup
        ManagedScaling:
          InstanceWarmupPeriod: 60
          MinimumScalingStepSize: 1
          MaximumScalingStepSize: 2
          Status: ENABLED
          # Percentage of cluster reservation to try to maintain
          TargetCapacity: 100
        ManagedTerminationProtection: DISABLED
        ManagedDraining: ENABLED

  # Create a cluster capacity provider association so that the cluster
  # will use the capacity provider
  CapacityProviderAssociation:
    Type: AWS::ECS::ClusterCapacityProviderAssociations
    Properties:
      CapacityProviders:
        - !Ref CapacityProvider
      Cluster: !Ref ECSCluster
      DefaultCapacityProviderStrategy:
        - Base: 0
          CapacityProvider: !Ref CapacityProvider
          Weight: 1

  # This is a role which is used within Fargate to allow the Fargate agent
  # to download images, and upload logs.
  ECSTaskExecutionRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Statement:
          - Effect: Allow
            Principal:
              Service: [ecs-tasks.amazonaws.com]
            Action: ['sts:AssumeRole']
            Condition:
              ArnLike:
                aws:SourceArn: !Sub arn:aws:ecs:${AWS::Region}:${AWS::AccountId}:*
              StringEquals:
                aws:SourceAccount: !Ref AWS::AccountId
      Path: /

      # This role enables basic features of ECS. See reference:
      ManagedPolicyArns:
        - arn:aws:iam::aws:policy/service-role/AmazonECSTaskExecutionRolePolicy

  ECSTaskDefinition:
    Type: AWS::ECS::TaskDefinition
    Properties:
      Family: backend-task
      NetworkMode: awsvpc
      RequiresCompatibilities:
        - EC2
      Cpu: '1792' # 87.5% of the 2 vCPUs available in t3.micro
      Memory: '700'
      ContainerDefinitions:
        - Name: backend-container
          Image: !Sub ${AWS::AccountId}.dkr.ecr.${AWS::Region}.amazonaws.com/${ECRRepositoryName}:${ImageTag}
          PortMappings:
            - ContainerPort: 4000
          MemoryReservation: 600
          Cpu: 1792
          LogConfiguration:
            LogDriver: awslogs
            Options:
              awslogs-group: !Ref CloudWatchLogsGroup
              awslogs-region: !Ref AWS::Region
              awslogs-stream-prefix: ecs

  CloudWatchLogsGroup:
    Type: AWS::Logs::LogGroup
    Properties:
      LogGroupName: /ecs/backend
      RetentionInDays: 14
    DeletionPolicy: Delete
    UpdateReplacePolicy: Retain 


  ECSService:
    Type: AWS::ECS::Service
    DependsOn: ALBListener
    Properties:
      ServiceName: BackendService
      Cluster: !Ref ECSCluster
      TaskDefinition: !Ref ECSTaskDefinition
      DesiredCount: !Ref DesiredCapacity # same as EC2 instances (1-1 relationship)
      PlacementStrategies:
        - Type: spread
          Field: attribute:ecs.availability-zone
        - Type: binpack
          Field: cpu
      CapacityProviderStrategy:
        - Base: !Ref DesiredCapacity
          CapacityProvider: !Ref CapacityProvider
          Weight: 1
      DeploymentConfiguration:
        MaximumPercent: 200
        MinimumHealthyPercent: 100
      NetworkConfiguration:
        AwsvpcConfiguration:
          AssignPublicIp: DISABLED
          Subnets:
            - !Ref PublicSubnet3 # set to private subnets in production
            - !Ref PublicSubnet4 # using public to avoid vpc endpoint costs (for ecs service)
          SecurityGroups:
            - !Ref EC2SecurityGroup
      LoadBalancers:
        - ContainerName: backend-container
          ContainerPort: 4000
          TargetGroupArn: !Ref ALBTargetGroup

  ECSServiceAutoScalingRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Statement:
          - Effect: Allow
            Principal:
              Service: application-autoscaling.amazonaws.com
            Action: sts:AssumeRole
      ManagedPolicyArns:
        - arn:aws:iam::aws:policy/service-role/AmazonEC2ContainerServiceAutoscaleRole

  ECSServiceScalableTarget:
    Type: AWS::ApplicationAutoScaling::ScalableTarget
    Properties:
      MaxCapacity: !Ref MaxSize # Correlate to ec2 max
      MinCapacity: !Ref MinSize # Correlate to ec2 min
      ResourceId: !Join
        - /
        - - service
          - !Ref ECSCluster
          - !GetAtt ECSService.Name
      RoleARN: !GetAtt ECSServiceAutoScalingRole.Arn
      ScalableDimension: ecs:service:DesiredCount
      ServiceNamespace: ecs

  ECSServiceScaleOutPolicy:
    Type: AWS::ApplicationAutoScaling::ScalingPolicy
    Properties:
      PolicyName: ECSServiceScaleOutPolicy
      PolicyType: StepScaling
      ScalingTargetId: !Ref ECSServiceScalableTarget
      StepScalingPolicyConfiguration:
        AdjustmentType: ChangeInCapacity
        Cooldown: 60
        MetricAggregationType: Average
        StepAdjustments:
          - MetricIntervalLowerBound: 0
            ScalingAdjustment: 1

  ECSServiceScaleInPolicy:
    Type: AWS::ApplicationAutoScaling::ScalingPolicy
    Properties:
      PolicyName: ECSServiceScaleInPolicy
      PolicyType: StepScaling
      ScalingTargetId: !Ref ECSServiceScalableTarget
      StepScalingPolicyConfiguration:
        AdjustmentType: ChangeInCapacity
        Cooldown: 60
        MetricAggregationType: Average
        StepAdjustments:
          - MetricIntervalUpperBound: 0
            ScalingAdjustment: -1

  ECSServiceCPUMemoryScaleOutAlarm:
    Type: AWS::CloudWatch::Alarm
    Properties:
      AlarmName: ECSServiceCPUMemoryScaleOutAlarm
      ComparisonOperator: GreaterThanOrEqualToThreshold
      EvaluationPeriods: 2
      Metrics:
        - Id: cpu
          MetricStat:
            Metric:
              Namespace: AWS/ECS
              MetricName: CPUUtilization
              Dimensions:
                - Name: ClusterName
                  Value: !Ref ECSCluster
                - Name: ServiceName
                  Value: !GetAtt ECSService.Name
            Period: 60
            Stat: Average
          ReturnData: false
        - Id: memory
          MetricStat:
            Metric:
              Namespace: AWS/ECS
              MetricName: MemoryUtilization
              Dimensions:
                - Name: ClusterName
                  Value: !Ref ECSCluster
                - Name: ServiceName
                  Value: !GetAtt ECSService.Name
            Period: 60
            Stat: Average
          ReturnData: false
        - Id: maxUtilization
          Expression: 'MAX([cpu, memory])'
          Label: Max of CPU and Memory Utilization
          ReturnData: true
      Threshold: 70
      AlarmDescription: Alarm when either CPU or Memory utilization is high
      AlarmActions:
        - !Ref ECSServiceScaleOutPolicy

  ECSServiceCPUMemoryScaleInAlarm:
    Type: AWS::CloudWatch::Alarm
    Properties:
      AlarmName: ECSServiceCPUMemoryScaleInAlarm
      ComparisonOperator: LessThanOrEqualToThreshold
      EvaluationPeriods: 2
      Metrics:
        - Id: cpu
          MetricStat:
            Metric:
              Namespace: AWS/ECS
              MetricName: CPUUtilization
              Dimensions:
                - Name: ClusterName
                  Value: !Ref ECSCluster
                - Name: ServiceName
                  Value: !GetAtt ECSService.Name
            Period: 300
            Stat: Average
          ReturnData: false
        - Id: memory
          MetricStat:
            Metric:
              Namespace: AWS/ECS
              MetricName: MemoryUtilization
              Dimensions:
                - Name: ClusterName
                  Value: !Ref ECSCluster
                - Name: ServiceName
                  Value: !GetAtt ECSService.Name
            Period: 300
            Stat: Average
          ReturnData: false

        - Id: minUtilization
          Expression: 'MAX([cpu, memory])'
          Label: Max of CPU and Memory Utilization
          ReturnData: true
      Threshold: 30
      AlarmDescription: Alarm when both CPU and Memory utilization are low
      AlarmActions:
        - !Ref ECSServiceScaleInPolicy

  # Because we are launching tasks in AWS VPC networking mode
  # the tasks themselves also have an extra security group that is unique
  # to them. This is a unique security group just for this service,
  # to control which things it can talk to, and who can talk to it
  ServiceSecurityGroup:
    Type: AWS::EC2::SecurityGroup
    Properties:
      GroupDescription: !Sub Access to service ${ECSService}
      VpcId: !Ref VPC

  ALB:
    Type: AWS::ElasticLoadBalancingV2::LoadBalancer
    Properties:
      Scheme: internet-facing
      SecurityGroups:
        - !Ref ALBSecurityGroup
      Subnets:
        - !Ref PublicSubnet1
        - !Ref PublicSubnet2

  ALBListener:
    Type: AWS::ElasticLoadBalancingV2::Listener
    Properties:
      DefaultActions:
        - Type: forward
          TargetGroupArn: !Ref ALBTargetGroup
      LoadBalancerArn: !Ref ALB
      Port: 443
      Protocol: HTTPS
      Certificates:
      - CertificateArn: !Ref ACMCertificate

  ALBTargetGroup:
    Type: AWS::ElasticLoadBalancingV2::TargetGroup
    Properties:
      HealthCheckPath: /health
      Name: ALBTargetGroup
      Port: 4000
      Protocol: HTTP
      TargetType: ip
      VpcId: !Ref VPC

  ALBSecurityGroup:
    Type: AWS::EC2::SecurityGroup
    Properties:
      GroupDescription: Security group for ALB
      VpcId: !Ref VPC
      SecurityGroupIngress:
        - IpProtocol: tcp
          FromPort: 443
          ToPort: 443
          CidrIp: 0.0.0.0/0
  
  ACMCertificate:
    Type: AWS::CertificateManager::Certificate
    Properties:
      DomainName: !Ref DomainName
      ValidationMethod: DNS
      DomainValidationOptions:
        - DomainName: !Ref DomainName
          HostedZoneId: !Ref HostedZoneId

  Route53RecordSet:
    Type: AWS::Route53::RecordSet
    Properties:
      HostedZoneId: !Ref HostedZoneId
      Name: !Ref DomainName
      Type: A
      AliasTarget:
        DNSName: !GetAtt ALB.DNSName
        HostedZoneId: !GetAtt ALB.CanonicalHostedZoneID

Outputs:
  VPC:
    Description: A reference to the created VPC
    Value: !Ref VPC
    Export:
      Name: !Sub ${AWS::StackName}-VPCID

  PublicSubnets:
    Description: A list of the public subnets
    Value:
      !Join [
        ',',
        [
          !Ref PublicSubnet1,
          !Ref PublicSubnet2,
          !Ref PublicSubnet3,
          !Ref PublicSubnet4,
        ],
      ]
    Export:
      Name: !Sub ${AWS::StackName}-PublicSubnets

  # PrivateSubnets:
  #   Description: A list of the private subnets
  #   Value: !Join [',', [!Ref PrivateSubnet1, !Ref PrivateSubnet2]]
  #   Export:
  #     Name: !Sub ${AWS::StackName}-PrivateSubnets

  ECSCluster:
    Description: A reference to the ECS cluster
    Value: !Ref ECSCluster
    Export:
      Name: !Sub ${AWS::StackName}-ECSCluster

  ECSServiceName:
    Description: Name of the ECS Service
    Value: !GetAtt ECSService.Name
    Export:
      Name: !Sub ${AWS::StackName}-ECSServiceName

  CapacityProvider:
    Description: The cluster capacity provider that the service should use
      to request capacity when it wants to start up a task
    Value: !Ref CapacityProvider

  ECSTaskDefinitionArn:
    Description: ARN of the Task Definition
    Value: !Ref ECSTaskDefinition
    Export:
      Name: !Sub ${AWS::StackName}-TaskDefinitionArn

  ALBDNSName:
    Description: DNS name of the Application Load Balancer
    Value: !GetAtt ALB.DNSName
    Export:
      Name: !Sub ${AWS::StackName}-ALBDNS
